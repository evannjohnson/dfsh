#!/bin/bash

set -eEuo pipefail
trap 'echo "Error occurred at line $LINENO"' ERR

DEBUG=1
# DFSH_REPO="$HOME/.cfg"
# DFSH_WORK="$HOME/sandbox/dotfiles-repo"
# DFSH_REPO="$HOME/sandbox/dotfiles-repo/.git"
# DFSH_WORK="$HOME/sandbox/dotfiles-repo"
SCRIPT_DIR="$(cd -- "$(dirname -- "$0")" && pwd)"
DFSH_REPO="${DFSH_REPO:-$SCRIPT_DIR/test/test-env/.dotfiles}"
DFSH_WORK="${DFSH_WORK:-$SCRIPT_DIR/test/test-env}"
MAIN_BRANCH="main"
GIT_PROGRAM="git"

git_df() {
  require_repo
  debug "running: $GIT_PROGRAM --git-dir=\"$DFSH_REPO\" --work-tree=\"$DFSH_WORK\" $*"
  "$GIT_PROGRAM" --git-dir="$DFSH_REPO" --work-tree="$DFSH_WORK" "$@"
  return "$?"
}

debug() {
  [ -n "$DEBUG" ] && printf 'DEBUG: %b\n' "$*"
}

require_repo() {
  [ -d "$DFSH_REPO" ] || error_exit "Git repo at '$DFSH_REPO' does not exist"
}

require_git() {
  command -v "$GIT_PROGRAM" &>/dev/null ||
    error_exit "Git cannot be located by invoking '$GIT_PROGRAM'"
}

qualify_path() {
  local path="$1"
  if [ -z "$path" ]; then
      error_exit "You can't specify an empty $2 path"
  fi

  if [ "$path" = "." ]; then
      path="$PWD"
  elif [[ "$path" != /* ]]; then
      path="$PWD/${path#./}"
  fi
  echo "$path"
}

error_exit() {
  printf 'Error: %b\n' "$*" >&2
  exit 1
}

commit() {
  # if [ -z "${FORCE:-}" ]; then
  #   stop_if_on_main
  #   ensure_up_to_date
  # fi
  stop_if_on_main
  # ensure_up_to_date

  git_df commit "$@"
}

commitm() {
  echo "not implemented"
}

clone() {
  "$GIT_PROGRAM" clone --bare "$@" "$DFSH_REPO"

  # by default, do not show untracked files and directories
  git_df config status.showUntrackedFiles no
}

# demonstrate common control structures
example_command() {
  local -a args

  while [[ $# -gt 0 ]] ; do
    case "$1" in
      --example-flag)
        # do something
      ;;
      *)
        args+=("$1")
      ;;
    esac
    shift
  done

  git_df "${args[@]}"
}

# print tracked files
ls() {
  echo "$(cd "$HOME"; git_df ls-tree -r main --name-only)"
}

ensure_up_to_date() {
  git_df fetch --all --prune
  git_df branch -r | grep -v '\->' | while read remote; do
    git_df branch --track "${remote#origin/}" "$remote"
  done

  current_branch="$(git_df rev-parse --abbrev-ref HEAD)"

  for remote_branch in $(git branch -r | grep -v '\->'); do
    local_branch=${remote_branch#origin/}

    # ensures that the current branch and main are both up to date
    if [ "$local_branch" = "$MAIN_BRANCH" ] || [ "$local_branch" = "$current_branch" ]; then
      # handle main
      if git show-ref --quiet refs/heads/"$local_branch"; then
        local_commit=$(git rev-parse "$local_branch")
        remote_commit=$(git rev-parse "$remote_branch")

        if [ "$local_commit" != "$remote_commit" ]; then
          error_exit "Local branch '$local_branch' is not up-to-date with '$remote_branch', could be ahead or behind"
        fi
      else
        error_exit "No local branch tracking '$remote_branch'"
      fi
    # elif [ "$local_branch" = "$current_branch" ]; then
        # handle this machine's branch
    # else [ ]; then
    # handle other machine's branches
    fi
  done
}

stop_if_on_main() {
  if [ "$(git_df rev-parse --abbrev-ref HEAD)" = "$MAIN_BRANCH" ];
  then
    error_exit "HEAD is on $MAIN_BRANCH, switch to machine branch and try again"
  fi
}

help() {
  cat <<EOF
help will go here
EOF
  exit
}

# echo replacements
function echo() {
  IFS=' '
  printf '%s\n' "$*"
}

main() {
  require_git

  # BRANCH="$(git_df rev-parse --abbrev-ref HEAD)"

  # parse command line arguments
  local retval=0
  internal_commands="^(commit|commitm|clone|ls|help|--help)$"
  if [ -z "$*" ]; then
    # no argumnts will result in help()
    help
  elif [[ "$1" =~ $internal_commands ]]; then
    # for internal commands, process all of the arguments
    DFSH_COMMAND="${1//-/_}"
    DFSH_COMMAND="${DFSH_COMMAND/__/}"
    DFSH_ARGS=()
    shift

    while [[ $# -gt 0 ]] ; do
      key="$1"
      case $key in
        -D)
          DEBUG="YES"
        ;;
        -F) # used by init(), clone() and upgrade()
          FORCE="YES"
        ;;
        -G) # set the git dir
          DFSH_REPO="$(qualify_path "$2" "work tree")"
          shift
        ;;
        -T) # set the work tree
          DFSH_WORK="$(qualify_path "$2" "work tree")"
          shift
        ;;
        *) # any unhandled arguments
          DFSH_ARGS+=("$1")
        ;;
      esac
      shift
    done

    [ ! -d "$DFSH_WORK" ] && error_exit "Work tree does not exist: [$DFSH_WORK]"

    # not using hooks for now
    # HOOK_COMMAND="$DFSH_COMMAND"
    # invoke_hook "pre"

    $DFSH_COMMAND "${DFSH_ARGS[@]:-}"
  else
      # any other commands are simply passed through to git
      git_df "$@"
      retval="$?"
  fi
}

main "$@"
